{"id":"../node_modules/@tonaljs/chord/dist/index.es.js","dependencies":[{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord\\dist\\index.es.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\package.json","includedInParent":true,"mtime":1596313178655},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord\\package.json","includedInParent":true,"mtime":1596312984530},{"name":"@tonaljs/chord-detect","loc":{"line":2,"column":23},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord-detect\\dist\\index.es.js"},{"name":"@tonaljs/chord-type","loc":{"line":3,"column":43},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord-type\\dist\\index.es.js"},{"name":"@tonaljs/core","loc":{"line":4,"column":82},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\core\\dist\\index.es.js"},{"name":"@tonaljs/pcset","loc":{"line":5,"column":41},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\pcset\\dist\\index.es.js"},{"name":"@tonaljs/scale-type","loc":{"line":6,"column":20},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale-type\\dist\\index.es.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chordScales = chordScales;\nexports.extended = extended;\nexports.get = get;\nexports.getChord = getChord;\nexports.reduced = reduced;\nexports.tokenize = tokenize;\nexports.transpose = transpose;\nObject.defineProperty(exports, \"detect\", {\n  enumerable: true,\n  get: function () {\n    return _chordDetect.detect;\n  }\n});\nexports.chord = exports.default = void 0;\n\nvar _chordDetect = require(\"@tonaljs/chord-detect\");\n\nvar _chordType = require(\"@tonaljs/chord-type\");\n\nvar _core = require(\"@tonaljs/core\");\n\nvar _pcset = require(\"@tonaljs/pcset\");\n\nvar _scaleType = require(\"@tonaljs/scale-type\");\n\nconst NoChord = {\n  empty: true,\n  name: \"\",\n  symbol: \"\",\n  root: \"\",\n  rootDegree: 0,\n  type: \"\",\n  tonic: null,\n  setNum: NaN,\n  quality: \"Unknown\",\n  chroma: \"\",\n  normalized: \"\",\n  aliases: [],\n  notes: [],\n  intervals: []\n}; // 6, 64, 7, 9, 11 and 13 are consider part of the chord\n// (see https://github.com/danigb/tonal/issues/55)\n\nconst NUM_TYPES = /^(6|64|7|9|11|13)$/;\n/**\r\n * Tokenize a chord name. It returns an array with the tonic and chord type\r\n * If not tonic is found, all the name is considered the chord name.\r\n *\r\n * This function does NOT check if the chord type exists or not. It only tries\r\n * to split the tonic and chord type.\r\n *\r\n * @function\r\n * @param {string} name - the chord name\r\n * @return {Array} an array with [tonic, type]\r\n * @example\r\n * tokenize(\"Cmaj7\") // => [ \"C\", \"maj7\" ]\r\n * tokenize(\"C7\") // => [ \"C\", \"7\" ]\r\n * tokenize(\"mMaj7\") // => [ null, \"mMaj7\" ]\r\n * tokenize(\"Cnonsense\") // => [ null, \"nonsense\" ]\r\n */\n\nfunction tokenize(name) {\n  const [letter, acc, oct, type] = (0, _core.tokenizeNote)(name);\n\n  if (letter === \"\") {\n    return [\"\", name];\n  } // aug is augmented (see https://github.com/danigb/tonal/issues/55)\n\n\n  if (letter === \"A\" && type === \"ug\") {\n    return [\"\", \"aug\"];\n  } // see: https://github.com/tonaljs/tonal/issues/70\n\n\n  if (!type && (oct === \"4\" || oct === \"5\")) {\n    return [letter + acc, oct];\n  }\n\n  if (NUM_TYPES.test(oct)) {\n    return [letter + acc, oct + type];\n  } else {\n    return [letter + acc + oct, type];\n  }\n}\n/**\r\n * Get a Chord from a chord name.\r\n */\n\n\nfunction get(src) {\n  if (src === \"\") {\n    return NoChord;\n  }\n\n  if (Array.isArray(src) && src.length === 2) {\n    return getChord(src[1], src[0]);\n  } else {\n    const [tonic, type] = tokenize(src);\n    const chord = getChord(type, tonic);\n    return chord.empty ? getChord(src) : chord;\n  }\n}\n/**\r\n * Get chord properties\r\n *\r\n * @param typeName - the chord type name\r\n * @param [tonic] - Optional tonic\r\n * @param [root]  - Optional root (requires a tonic)\r\n */\n\n\nfunction getChord(typeName, optionalTonic, optionalRoot) {\n  const type = (0, _chordType.get)(typeName);\n  const tonic = (0, _core.note)(optionalTonic || \"\");\n  const root = (0, _core.note)(optionalRoot || \"\");\n\n  if (type.empty || optionalTonic && tonic.empty || optionalRoot && root.empty) {\n    return NoChord;\n  }\n\n  const rootInterval = (0, _core.distance)(tonic.pc, root.pc);\n  const rootDegree = type.intervals.indexOf(rootInterval) + 1;\n\n  if (!root.empty && !rootDegree) {\n    return NoChord;\n  }\n\n  const notes = tonic.empty ? [] : type.intervals.map(i => (0, _core.transpose)(tonic, i));\n  typeName = type.aliases.indexOf(typeName) !== -1 ? typeName : type.aliases[0];\n  const symbol = `${tonic.empty ? \"\" : tonic.pc}${typeName}${root.empty ? \"\" : \"/\" + root.pc}`;\n  const name = `${optionalTonic ? tonic.pc + \" \" : \"\"}${type.name}${optionalRoot ? \" over \" + root.pc : \"\"}`;\n  return { ...type,\n    name,\n    symbol,\n    type: type.name,\n    root: root.name,\n    rootDegree,\n    tonic: tonic.name,\n    notes\n  };\n}\n\nconst chord = (0, _core.deprecate)(\"Chord.chord\", \"Chord.get\", get);\n/**\r\n * Transpose a chord name\r\n *\r\n * @param {string} chordName - the chord name\r\n * @return {string} the transposed chord\r\n *\r\n * @example\r\n * transpose('Dm7', 'P4') // => 'Gm7\r\n */\n\nexports.chord = chord;\n\nfunction transpose(chordName, interval) {\n  const [tonic, type] = tokenize(chordName);\n\n  if (!tonic) {\n    return chordName;\n  }\n\n  return (0, _core.transpose)(tonic, interval) + type;\n}\n/**\r\n * Get all scales where the given chord fits\r\n *\r\n * @example\r\n * chordScales('C7b9')\r\n * // => [\"phrygian dominant\", \"flamenco\", \"spanish heptatonic\", \"half-whole diminished\", \"chromatic\"]\r\n */\n\n\nfunction chordScales(name) {\n  const s = get(name);\n  const isChordIncluded = (0, _pcset.isSupersetOf)(s.chroma);\n  return (0, _scaleType.all)().filter(scale => isChordIncluded(scale.chroma)).map(scale => scale.name);\n}\n/**\r\n * Get all chords names that are a superset of the given one\r\n * (has the same notes and at least one more)\r\n *\r\n * @function\r\n * @example\r\n * extended(\"CMaj7\")\r\n * // => [ 'Cmaj#4', 'Cmaj7#9#11', 'Cmaj9', 'CM7add13', 'Cmaj13', 'Cmaj9#11', 'CM13#11', 'CM7b9' ]\r\n */\n\n\nfunction extended(chordName) {\n  const s = get(chordName);\n  const isSuperset = (0, _pcset.isSupersetOf)(s.chroma);\n  return (0, _chordType.all)().filter(chord => isSuperset(chord.chroma)).map(chord => s.tonic + chord.aliases[0]);\n}\n/**\r\n * Find all chords names that are a subset of the given one\r\n * (has less notes but all from the given chord)\r\n *\r\n * @example\r\n */\n\n\nfunction reduced(chordName) {\n  const s = get(chordName);\n  const isSubset = (0, _pcset.isSubsetOf)(s.chroma);\n  return (0, _chordType.all)().filter(chord => isSubset(chord.chroma)).map(chord => s.tonic + chord.aliases[0]);\n}\n\nvar index = {\n  getChord,\n  get,\n  detect: _chordDetect.detect,\n  chordScales,\n  extended,\n  reduced,\n  tokenize,\n  transpose,\n  // deprecate\n  chord\n};\nvar _default = index;\nexports.default = _default;"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"ee850fcbfa76b82f03c32867c5d94470","cacheData":{"env":{}}}