{"id":"../node_modules/@tonaljs/pcset/dist/index.es.js","dependencies":[{"name":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\@tonaljs\\pcset\\dist\\index.es.js.map","includedInParent":true,"mtime":1596323947663},{"name":"C:\\Projects\\ChordHolder\\ChordHolder\\package.json","includedInParent":true,"mtime":1596323959438},{"name":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\@tonaljs\\pcset\\package.json","includedInParent":true,"mtime":1596323947666},{"name":"@tonaljs/collection","loc":{"line":1,"column":39},"parent":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\@tonaljs\\pcset\\dist\\index.es.js","resolved":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\@tonaljs\\collection\\dist\\index.es.js"},{"name":"@tonaljs/core","loc":{"line":2,"column":42},"parent":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\@tonaljs\\pcset\\dist\\index.es.js","resolved":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\@tonaljs\\core\\dist\\index.es.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chromaToIntervals = chromaToIntervals;\nexports.chromas = chromas;\nexports.filter = filter;\nexports.get = get;\nexports.isEqual = isEqual;\nexports.isNoteIncludedIn = isNoteIncludedIn;\nexports.isSubsetOf = isSubsetOf;\nexports.isSupersetOf = isSupersetOf;\nexports.modes = modes;\nexports.pcset = exports.includes = exports.EmptyPcset = exports.default = void 0;\n\nvar _collection = require(\"@tonaljs/collection\");\n\nvar _core = require(\"@tonaljs/core\");\n\nconst EmptyPcset = {\n  empty: true,\n  name: \"\",\n  setNum: 0,\n  chroma: \"000000000000\",\n  normalized: \"000000000000\",\n  intervals: []\n}; // UTILITIES\n\nexports.EmptyPcset = EmptyPcset;\n\nconst setNumToChroma = num => Number(num).toString(2);\n\nconst chromaToNumber = chroma => parseInt(chroma, 2);\n\nconst REGEX = /^[01]{12}$/;\n\nfunction isChroma(set) {\n  return REGEX.test(set);\n}\n\nconst isPcsetNum = set => typeof set === \"number\" && set >= 0 && set <= 4095;\n\nconst isPcset = set => set && isChroma(set.chroma);\n\nconst cache = {\n  [EmptyPcset.chroma]: EmptyPcset\n};\n/**\r\n * Get the pitch class set of a collection of notes or set number or chroma\r\n */\n\nfunction get(src) {\n  const chroma = isChroma(src) ? src : isPcsetNum(src) ? setNumToChroma(src) : Array.isArray(src) ? listToChroma(src) : isPcset(src) ? src.chroma : EmptyPcset.chroma;\n  return cache[chroma] = cache[chroma] || chromaToPcset(chroma);\n}\n/**\r\n * Use Pcset.properties\r\n * @function\r\n * @deprecated\r\n */\n\n\nconst pcset = (0, _core.deprecate)(\"Pcset.pcset\", \"Pcset.get\", get);\n/**\r\n * Get pitch class set chroma\r\n * @function\r\n * @example\r\n * Pcset.chroma([\"c\", \"d\", \"e\"]); //=> \"101010000000\"\r\n */\n\nexports.pcset = pcset;\n\nconst chroma = set => get(set).chroma;\n/**\r\n * Get intervals (from C) of a set\r\n * @function\r\n * @example\r\n * Pcset.intervals([\"c\", \"d\", \"e\"]); //=>\r\n */\n\n\nconst intervals = set => get(set).intervals;\n/**\r\n * Get pitch class set number\r\n * @function\r\n * @example\r\n * Pcset.num([\"c\", \"d\", \"e\"]); //=> 2192\r\n */\n\n\nconst num = set => get(set).setNum;\n\nconst IVLS = [\"1P\", \"2m\", \"2M\", \"3m\", \"3M\", \"4P\", \"5d\", \"5P\", \"6m\", \"6M\", \"7m\", \"7M\"];\n/**\r\n * @private\r\n * Get the intervals of a pcset *starting from C*\r\n * @param {Set} set - the pitch class set\r\n * @return {IntervalName[]} an array of interval names or an empty array\r\n * if not a valid pitch class set\r\n */\n\nfunction chromaToIntervals(chroma) {\n  const intervals = [];\n\n  for (let i = 0; i < 12; i++) {\n    // tslint:disable-next-line:curly\n    if (chroma.charAt(i) === \"1\") intervals.push(IVLS[i]);\n  }\n\n  return intervals;\n}\n/**\r\n * Get a list of all possible pitch class sets (all possible chromas) *having\r\n * C as root*. There are 2048 different chromas. If you want them with another\r\n * note you have to transpose it\r\n *\r\n * @see http://allthescales.org/\r\n * @return {Array<PcsetChroma>} an array of possible chromas from '10000000000' to '11111111111'\r\n */\n\n\nfunction chromas() {\n  return (0, _collection.range)(2048, 4095).map(setNumToChroma);\n}\n/**\r\n * Given a a list of notes or a pcset chroma, produce the rotations\r\n * of the chroma discarding the ones that starts with \"0\"\r\n *\r\n * This is used, for example, to get all the modes of a scale.\r\n *\r\n * @param {Array|string} set - the list of notes or pitchChr of the set\r\n * @param {boolean} normalize - (Optional, true by default) remove all\r\n * the rotations that starts with \"0\"\r\n * @return {Array<string>} an array with all the modes of the chroma\r\n *\r\n * @example\r\n * Pcset.modes([\"C\", \"D\", \"E\"]).map(Pcset.intervals)\r\n */\n\n\nfunction modes(set, normalize = true) {\n  const pcs = get(set);\n  const binary = pcs.chroma.split(\"\");\n  return (0, _collection.compact)(binary.map((_, i) => {\n    const r = (0, _collection.rotate)(i, binary);\n    return normalize && r[0] === \"0\" ? null : r.join(\"\");\n  }));\n}\n/**\r\n * Test if two pitch class sets are numentical\r\n *\r\n * @param {Array|string} set1 - one of the pitch class sets\r\n * @param {Array|string} set2 - the other pitch class set\r\n * @return {boolean} true if they are equal\r\n * @example\r\n * Pcset.isEqual([\"c2\", \"d3\"], [\"c5\", \"d2\"]) // => true\r\n */\n\n\nfunction isEqual(s1, s2) {\n  return get(s1).setNum === get(s2).setNum;\n}\n/**\r\n * Create a function that test if a collection of notes is a\r\n * subset of a given set\r\n *\r\n * The function is curryfied.\r\n *\r\n * @param {PcsetChroma|NoteName[]} set - the superset to test against (chroma or\r\n * list of notes)\r\n * @return{function(PcsetChroma|NoteNames[]): boolean} a function accepting a set\r\n * to test against (chroma or list of notes)\r\n * @example\r\n * const inCMajor = Pcset.isSubsetOf([\"C\", \"E\", \"G\"])\r\n * inCMajor([\"e6\", \"c4\"]) // => true\r\n * inCMajor([\"e6\", \"c4\", \"d3\"]) // => false\r\n */\n\n\nfunction isSubsetOf(set) {\n  const s = get(set).setNum;\n  return notes => {\n    const o = get(notes).setNum; // tslint:disable-next-line: no-bitwise\n\n    return s && s !== o && (o & s) === o;\n  };\n}\n/**\r\n * Create a function that test if a collection of notes is a\r\n * superset of a given set (it contains all notes and at least one more)\r\n *\r\n * @param {Set} set - an array of notes or a chroma set string to test against\r\n * @return {(subset: Set): boolean} a function that given a set\r\n * returns true if is a subset of the first one\r\n * @example\r\n * const extendsCMajor = Pcset.isSupersetOf([\"C\", \"E\", \"G\"])\r\n * extendsCMajor([\"e6\", \"a\", \"c4\", \"g2\"]) // => true\r\n * extendsCMajor([\"c6\", \"e4\", \"g3\"]) // => false\r\n */\n\n\nfunction isSupersetOf(set) {\n  const s = get(set).setNum;\n  return notes => {\n    const o = get(notes).setNum; // tslint:disable-next-line: no-bitwise\n\n    return s && s !== o && (o | s) === o;\n  };\n}\n/**\r\n * Test if a given pitch class set includes a note\r\n *\r\n * @param {Array<string>} set - the base set to test against\r\n * @param {string} note - the note to test\r\n * @return {boolean} true if the note is included in the pcset\r\n *\r\n * Can be partially applied\r\n *\r\n * @example\r\n * const isNoteInCMajor = isNoteIncludedIn(['C', 'E', 'G'])\r\n * isNoteInCMajor('C4') // => true\r\n * isNoteInCMajor('C#4') // => false\r\n */\n\n\nfunction isNoteIncludedIn(set) {\n  const s = get(set);\n  return noteName => {\n    const n = (0, _core.note)(noteName);\n    return s && !n.empty && s.chroma.charAt(n.chroma) === \"1\";\n  };\n}\n/** @deprecated use: isNoteIncludedIn */\n\n\nconst includes = isNoteIncludedIn;\n/**\r\n * Filter a list with a pitch class set\r\n *\r\n * @param {Array|string} set - the pitch class set notes\r\n * @param {Array|string} notes - the note list to be filtered\r\n * @return {Array} the filtered notes\r\n *\r\n * @example\r\n * Pcset.filter([\"C\", \"D\", \"E\"], [\"c2\", \"c#2\", \"d2\", \"c3\", \"c#3\", \"d3\"]) // => [ \"c2\", \"d2\", \"c3\", \"d3\" ])\r\n * Pcset.filter([\"C2\"], [\"c2\", \"c#2\", \"d2\", \"c3\", \"c#3\", \"d3\"]) // => [ \"c2\", \"c3\" ])\r\n */\n\nexports.includes = includes;\n\nfunction filter(set) {\n  const isIncluded = isNoteIncludedIn(set);\n  return notes => {\n    return notes.filter(isIncluded);\n  };\n}\n\nvar index = {\n  get,\n  chroma,\n  num,\n  intervals,\n  chromas,\n  isSupersetOf,\n  isSubsetOf,\n  isNoteIncludedIn,\n  isEqual,\n  filter,\n  modes,\n  // deprecated\n  pcset\n}; //// PRIVATE ////\n\nfunction chromaRotations(chroma) {\n  const binary = chroma.split(\"\");\n  return binary.map((_, i) => (0, _collection.rotate)(i, binary).join(\"\"));\n}\n\nfunction chromaToPcset(chroma) {\n  const setNum = chromaToNumber(chroma);\n  const normalizedNum = chromaRotations(chroma).map(chromaToNumber).filter(n => n >= 2048).sort()[0];\n  const normalized = setNumToChroma(normalizedNum);\n  const intervals = chromaToIntervals(chroma);\n  return {\n    empty: false,\n    name: \"\",\n    setNum,\n    chroma,\n    normalized,\n    intervals\n  };\n}\n\nfunction listToChroma(set) {\n  if (set.length === 0) {\n    return EmptyPcset.chroma;\n  }\n\n  let pitch;\n  const binary = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // tslint:disable-next-line:prefer-for-of\n\n  for (let i = 0; i < set.length; i++) {\n    pitch = (0, _core.note)(set[i]); // tslint:disable-next-line: curly\n\n    if (pitch.empty) pitch = (0, _core.interval)(set[i]); // tslint:disable-next-line: curly\n\n    if (!pitch.empty) binary[pitch.chroma] = 1;\n  }\n\n  return binary.join(\"\");\n}\n\nvar _default = index;\nexports.default = _default;"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"d57df182e06b307a5229c6fe37406355","cacheData":{"env":{}}}