{"id":"../node_modules/@tonaljs/interval/dist/index.es.js","dependencies":[{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\interval\\dist\\index.es.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\package.json","includedInParent":true,"mtime":1596313178655},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\interval\\package.json","includedInParent":true,"mtime":1596312984530},{"name":"@tonaljs/core","loc":{"line":1,"column":66},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\interval\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\core\\dist\\index.es.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromSemitones = fromSemitones;\nexports.invert = invert;\nexports.names = names;\nexports.simplify = simplify;\nexports.substract = exports.semitones = exports.quality = exports.num = exports.name = exports.get = exports.distance = exports.addTo = exports.add = exports.default = void 0;\n\nvar _core = require(\"@tonaljs/core\");\n\n/**\r\n * Get the natural list of names\r\n */\nfunction names() {\n  return \"1P 2M 3M 4P 5P 6m 7m\".split(\" \");\n}\n/**\r\n * Get properties of an interval\r\n *\r\n * @function\r\n * @example\r\n * Interval.get('P4') // => {\"alt\": 0,  \"dir\": 1,  \"name\": \"4P\", \"num\": 4, \"oct\": 0, \"q\": \"P\", \"semitones\": 5, \"simple\": 4, \"step\": 3, \"type\": \"perfectable\"}\r\n */\n\n\nconst get = _core.interval;\n/**\r\n * Get name of an interval\r\n *\r\n * @function\r\n * @example\r\n * Interval.name('4P') // => \"4P\"\r\n * Interval.name('P4') // => \"4P\"\r\n * Interval.name('C4') // => \"\"\r\n */\n\nexports.get = get;\n\nconst name = name => (0, _core.interval)(name).name;\n/**\r\n * Get semitones of an interval\r\n * @function\r\n * @example\r\n * Interval.semitones('P4') // => 5\r\n */\n\n\nexports.name = name;\n\nconst semitones = name => (0, _core.interval)(name).semitones;\n/**\r\n * Get quality of an interval\r\n * @function\r\n * @example\r\n * Interval.quality('P4') // => \"P\"\r\n */\n\n\nexports.semitones = semitones;\n\nconst quality = name => (0, _core.interval)(name).q;\n/**\r\n * Get number of an interval\r\n * @function\r\n * @example\r\n * Interval.num('P4') // => 4\r\n */\n\n\nexports.quality = quality;\n\nconst num = name => (0, _core.interval)(name).num;\n/**\r\n * Get the simplified version of an interval.\r\n *\r\n * @function\r\n * @param {string} interval - the interval to simplify\r\n * @return {string} the simplified interval\r\n *\r\n * @example\r\n * Interval.simplify(\"9M\") // => \"2M\"\r\n * Interval.simplify(\"2M\") // => \"2M\"\r\n * Interval.simplify(\"-2M\") // => \"7m\"\r\n * [\"8P\", \"9M\", \"10M\", \"11P\", \"12P\", \"13M\", \"14M\", \"15P\"].map(Interval.simplify)\r\n * // => [ \"8P\", \"2M\", \"3M\", \"4P\", \"5P\", \"6M\", \"7M\", \"8P\" ]\r\n */\n\n\nexports.num = num;\n\nfunction simplify(name) {\n  const i = (0, _core.interval)(name);\n  return i.empty ? \"\" : i.simple + i.q;\n}\n/**\r\n * Get the inversion (https://en.wikipedia.org/wiki/Inversion_(music)#Intervals)\r\n * of an interval.\r\n *\r\n * @function\r\n * @param {string} interval - the interval to invert in interval shorthand\r\n * notation or interval array notation\r\n * @return {string} the inverted interval\r\n *\r\n * @example\r\n * Interval.invert(\"3m\") // => \"6M\"\r\n * Interval.invert(\"2M\") // => \"7m\"\r\n */\n\n\nfunction invert(name) {\n  const i = (0, _core.interval)(name);\n\n  if (i.empty) {\n    return \"\";\n  }\n\n  const step = (7 - i.step) % 7;\n  const alt = i.type === \"perfectable\" ? -i.alt : -(i.alt + 1);\n  return (0, _core.interval)({\n    step,\n    alt,\n    oct: i.oct,\n    dir: i.dir\n  }).name;\n} // interval numbers\n\n\nconst IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7]; // interval qualities\n\nconst IQ = \"P m M m M P d P m M m M\".split(\" \");\n/**\r\n * Get interval name from semitones number. Since there are several interval\r\n * names for the same number, the name it's arbitrary, but deterministic.\r\n *\r\n * @param {Integer} num - the number of semitones (can be negative)\r\n * @return {string} the interval name\r\n * @example\r\n * Interval.fromSemitones(7) // => \"5P\"\r\n * Interval.fromSemitones(-7) // => \"-5P\"\r\n */\n\nfunction fromSemitones(semitones) {\n  const d = semitones < 0 ? -1 : 1;\n  const n = Math.abs(semitones);\n  const c = n % 12;\n  const o = Math.floor(n / 12);\n  return d * (IN[c] + 7 * o) + IQ[c];\n}\n/**\r\n * Find interval between two notes\r\n *\r\n * @example\r\n * Interval.distance(\"C4\", \"G4\"); // => \"5P\"\r\n */\n\n\nconst distance = _core.distance;\n/**\r\n * Adds two intervals\r\n *\r\n * @function\r\n * @param {string} interval1\r\n * @param {string} interval2\r\n * @return {string} the added interval name\r\n * @example\r\n * Interval.add(\"3m\", \"5P\") // => \"7m\"\r\n */\n\nexports.distance = distance;\nconst add = combinator((a, b) => [a[0] + b[0], a[1] + b[1]]);\n/**\r\n * Returns a function that adds an interval\r\n *\r\n * @function\r\n * @example\r\n * ['1P', '2M', '3M'].map(Interval.addTo('5P')) // => [\"5P\", \"6M\", \"7M\"]\r\n */\n\nexports.add = add;\n\nconst addTo = interval => other => add(interval, other);\n/**\r\n * Subtracts two intervals\r\n *\r\n * @function\r\n * @param {string} minuendInterval\r\n * @param {string} subtrahendInterval\r\n * @return {string} the substracted interval name\r\n * @example\r\n * Interval.substract('5P', '3M') // => '3m'\r\n * Interval.substract('3M', '5P') // => '-3m'\r\n */\n\n\nexports.addTo = addTo;\nconst substract = combinator((a, b) => [a[0] - b[0], a[1] - b[1]]);\nexports.substract = substract;\nvar index = {\n  names,\n  get,\n  name,\n  num,\n  semitones,\n  quality,\n  fromSemitones,\n  distance,\n  invert,\n  simplify,\n  add,\n  addTo,\n  substract\n};\n\nfunction combinator(fn) {\n  return (a, b) => {\n    const coordA = (0, _core.interval)(a).coord;\n    const coordB = (0, _core.interval)(b).coord;\n\n    if (coordA && coordB) {\n      const coord = fn(coordA, coordB);\n      return (0, _core.coordToInterval)(coord).name;\n    }\n  };\n}\n\nvar _default = index;\nexports.default = _default;"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"87a0b3c1c19e888020395f86f788f630","cacheData":{"env":{}}}