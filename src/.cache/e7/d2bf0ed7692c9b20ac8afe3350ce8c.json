{"id":"../node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js","dependencies":[{"name":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\tone\\build\\esm\\core\\worklet\\DelayLine.worklet.js.map","includedInParent":true,"mtime":1596323958890},{"name":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\tone\\Tone\\core\\worklet\\DelayLine.worklet.ts","includedInParent":true,"mtime":1596323958565},{"name":"C:\\Projects\\ChordHolder\\ChordHolder\\package.json","includedInParent":true,"mtime":1596323959438},{"name":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\tone\\package.json","includedInParent":true,"mtime":1596323959121},{"name":"./WorkletGlobalScope","loc":{"line":1,"column":29},"parent":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\tone\\build\\esm\\core\\worklet\\DelayLine.worklet.js","resolved":"C:\\Projects\\ChordHolder\\ChordHolder\\node_modules\\tone\\build\\esm\\core\\worklet\\WorkletGlobalScope.js"}],"generated":{"js":"\"use strict\";\n\nvar _WorkletGlobalScope = require(\"./WorkletGlobalScope\");\n\nconst delayLine =\n/* javascript */\n`\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n`;\n(0, _WorkletGlobalScope.addToWorklet)(delayLine);"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":3,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":5,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":6},"generated":{"line":5,"column":6}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":15},"generated":{"line":5,"column":15}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":18},"generated":{"line":6,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":35},"generated":{"line":7,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":51,"column":1}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":0},"generated":{"line":52,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":13},"generated":{"line":52,"column":38}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":0},"generated":{"line":52,"column":47}}],"sources":{"../../../../Tone/core/worklet/DelayLine.worklet.ts":"import { addToWorklet } from \"./WorkletGlobalScope\";\r\n\r\nconst delayLine = /* javascript */ `\r\n\t/**\r\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\r\n\t */\r\n\tclass DelayLine {\r\n\t\t\r\n\t\tconstructor(size, channels) {\r\n\t\t\tthis.buffer = [];\r\n\t\t\tthis.writeHead = []\r\n\t\t\tthis.size = size;\r\n\r\n\t\t\t// create the empty channels\r\n\t\t\tfor (let i = 0; i < channels; i++) {\r\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\r\n\t\t\t\tthis.writeHead[i] = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Push a value onto the end\r\n\t\t * @param channel number\r\n\t\t * @param value number\r\n\t\t */\r\n\t\tpush(channel, value) {\r\n\t\t\tthis.writeHead[channel] += 1;\r\n\t\t\tif (this.writeHead[channel] > this.size) {\r\n\t\t\t\tthis.writeHead[channel] = 0;\r\n\t\t\t}\r\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Get the recorded value of the channel given the delay\r\n\t\t * @param channel number\r\n\t\t * @param delay number delay samples\r\n\t\t */\r\n\t\tget(channel, delay) {\r\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\r\n\t\t\tif (readHead < 0) {\r\n\t\t\t\treadHead += this.size;\r\n\t\t\t}\r\n\t\t\treturn this.buffer[channel][readHead];\r\n\t\t}\r\n\t}\r\n`;\r\n\r\naddToWorklet(delayLine);\r\n"},"lineCount":null}},"error":null,"hash":"fca444660a389d41ff40dbaa10989895","cacheData":{"env":{}}}