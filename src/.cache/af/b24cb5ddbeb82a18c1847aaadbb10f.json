{"id":"../node_modules/@tonaljs/scale/dist/index.es.js","dependencies":[{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale\\dist\\index.es.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\package.json","includedInParent":true,"mtime":1596313178655},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale\\package.json","includedInParent":true,"mtime":1596312984530},{"name":"@tonaljs/chord-type","loc":{"line":1,"column":20},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\chord-type\\dist\\index.es.js"},{"name":"@tonaljs/collection","loc":{"line":2,"column":23},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\collection\\dist\\index.es.js"},{"name":"@tonaljs/core","loc":{"line":3,"column":43},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\core\\dist\\index.es.js"},{"name":"@tonaljs/note","loc":{"line":4,"column":32},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\note\\dist\\index.es.js"},{"name":"@tonaljs/pcset","loc":{"line":5,"column":48},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\pcset\\dist\\index.es.js"},{"name":"@tonaljs/scale-type","loc":{"line":6,"column":61},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale\\dist\\index.es.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\@tonaljs\\scale-type\\dist\\index.es.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extended = extended;\nexports.get = get;\nexports.modeNames = modeNames;\nexports.reduced = reduced;\nexports.scaleChords = scaleChords;\nexports.scaleNotes = scaleNotes;\nexports.tokenize = tokenize;\nexports.scale = exports.names = exports.default = void 0;\n\nvar _chordType = require(\"@tonaljs/chord-type\");\n\nvar _collection = require(\"@tonaljs/collection\");\n\nvar _core = require(\"@tonaljs/core\");\n\nvar _note = require(\"@tonaljs/note\");\n\nvar _pcset = require(\"@tonaljs/pcset\");\n\nvar _scaleType = require(\"@tonaljs/scale-type\");\n\n/**\r\n * References:\r\n * - https://www.researchgate.net/publication/327567188_An_Algorithm_for_Spelling_the_Pitches_of_Any_Musical_Scale\r\n * @module scale\r\n */\nconst NoScale = {\n  empty: true,\n  name: \"\",\n  type: \"\",\n  tonic: null,\n  setNum: NaN,\n  chroma: \"\",\n  normalized: \"\",\n  aliases: [],\n  notes: [],\n  intervals: []\n};\n/**\r\n * Given a string with a scale name and (optionally) a tonic, split\r\n * that components.\r\n *\r\n * It retuns an array with the form [ name, tonic ] where tonic can be a\r\n * note name or null and name can be any arbitrary string\r\n * (this function doesn\"t check if that scale name exists)\r\n *\r\n * @function\r\n * @param {string} name - the scale name\r\n * @return {Array} an array [tonic, name]\r\n * @example\r\n * tokenize(\"C mixolydean\") // => [\"C\", \"mixolydean\"]\r\n * tokenize(\"anything is valid\") // => [\"\", \"anything is valid\"]\r\n * tokenize() // => [\"\", \"\"]\r\n */\n\nfunction tokenize(name) {\n  if (typeof name !== \"string\") {\n    return [\"\", \"\"];\n  }\n\n  const i = name.indexOf(\" \");\n  const tonic = (0, _core.note)(name.substring(0, i));\n\n  if (tonic.empty) {\n    const n = (0, _core.note)(name);\n    return n.empty ? [\"\", name] : [n.name, \"\"];\n  }\n\n  const type = name.substring(tonic.name.length + 1);\n  return [tonic.name, type.length ? type : \"\"];\n}\n/**\r\n * Get all scale names\r\n * @function\r\n */\n\n\nconst names = _scaleType.names;\n/**\r\n * Get a Scale from a scale name.\r\n */\n\nexports.names = names;\n\nfunction get(src) {\n  const tokens = Array.isArray(src) ? src : tokenize(src);\n  const tonic = (0, _core.note)(tokens[0]).name;\n  const st = (0, _scaleType.get)(tokens[1]);\n\n  if (st.empty) {\n    return NoScale;\n  }\n\n  const type = st.name;\n  const notes = tonic ? st.intervals.map(i => (0, _core.transpose)(tonic, i)) : [];\n  const name = tonic ? tonic + \" \" + type : type;\n  return { ...st,\n    name,\n    type,\n    tonic,\n    notes\n  };\n}\n\nconst scale = (0, _core.deprecate)(\"Scale.scale\", \"Scale.get\", get);\n/**\r\n * Get all chords that fits a given scale\r\n *\r\n * @function\r\n * @param {string} name - the scale name\r\n * @return {Array<string>} - the chord names\r\n *\r\n * @example\r\n * scaleChords(\"pentatonic\") // => [\"5\", \"64\", \"M\", \"M6\", \"Madd9\", \"Msus2\"]\r\n */\n\nexports.scale = scale;\n\nfunction scaleChords(name) {\n  const s = get(name);\n  const inScale = (0, _pcset.isSubsetOf)(s.chroma);\n  return (0, _chordType.all)().filter(chord => inScale(chord.chroma)).map(chord => chord.aliases[0]);\n}\n/**\r\n * Get all scales names that are a superset of the given one\r\n * (has the same notes and at least one more)\r\n *\r\n * @function\r\n * @param {string} name\r\n * @return {Array} a list of scale names\r\n * @example\r\n * extended(\"major\") // => [\"bebop\", \"bebop dominant\", \"bebop major\", \"chromatic\", \"ichikosucho\"]\r\n */\n\n\nfunction extended(name) {\n  const s = get(name);\n  const isSuperset = (0, _pcset.isSupersetOf)(s.chroma);\n  return (0, _scaleType.all)().filter(scale => isSuperset(scale.chroma)).map(scale => scale.name);\n}\n/**\r\n * Find all scales names that are a subset of the given one\r\n * (has less notes but all from the given scale)\r\n *\r\n * @function\r\n * @param {string} name\r\n * @return {Array} a list of scale names\r\n *\r\n * @example\r\n * reduced(\"major\") // => [\"ionian pentatonic\", \"major pentatonic\", \"ritusen\"]\r\n */\n\n\nfunction reduced(name) {\n  const isSubset = (0, _pcset.isSubsetOf)(get(name).chroma);\n  return (0, _scaleType.all)().filter(scale => isSubset(scale.chroma)).map(scale => scale.name);\n}\n/**\r\n * Given an array of notes, return the scale: a pitch class set starting from\r\n * the first note of the array\r\n *\r\n * @function\r\n * @param {string[]} notes\r\n * @return {string[]} pitch classes with same tonic\r\n * @example\r\n * scaleNotes(['C4', 'c3', 'C5', 'C4', 'c4']) // => [\"C\"]\r\n * scaleNotes(['D4', 'c#5', 'A5', 'F#6']) // => [\"D\", \"F#\", \"A\", \"C#\"]\r\n */\n\n\nfunction scaleNotes(notes) {\n  const pcset = notes.map(n => (0, _core.note)(n).pc).filter(x => x);\n  const tonic = pcset[0];\n  const scale = (0, _note.sortedUniqNames)(pcset);\n  return (0, _collection.rotate)(scale.indexOf(tonic), scale);\n}\n/**\r\n * Find mode names of a scale\r\n *\r\n * @function\r\n * @param {string} name - scale name\r\n * @example\r\n * modeNames(\"C pentatonic\") // => [\r\n *   [\"C\", \"major pentatonic\"],\r\n *   [\"D\", \"egyptian\"],\r\n *   [\"E\", \"malkos raga\"],\r\n *   [\"G\", \"ritusen\"],\r\n *   [\"A\", \"minor pentatonic\"]\r\n * ]\r\n */\n\n\nfunction modeNames(name) {\n  const s = get(name);\n\n  if (s.empty) {\n    return [];\n  }\n\n  const tonics = s.tonic ? s.notes : s.intervals;\n  return (0, _pcset.modes)(s.chroma).map((chroma, i) => {\n    const modeName = get(chroma).name;\n    return modeName ? [tonics[i], modeName] : [\"\", \"\"];\n  }).filter(x => x[0]);\n}\n\nvar index = {\n  get,\n  names,\n  extended,\n  modeNames,\n  reduced,\n  scaleChords,\n  scaleNotes,\n  tokenize,\n  // deprecated\n  scale\n};\nvar _default = index;\nexports.default = _default;"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"5d8f1cb5272ec7431508a03baa060d44","cacheData":{"env":{}}}