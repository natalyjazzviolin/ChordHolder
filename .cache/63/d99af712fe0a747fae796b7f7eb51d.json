{"id":"../node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js","dependencies":[{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\SingleIOProcessor.worklet.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\Tone\\core\\worklet\\SingleIOProcessor.worklet.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\package.json","includedInParent":true,"mtime":1596313565786},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\package.json","includedInParent":true,"mtime":1596312949653},{"name":"./ToneAudioWorkletProcessor.worklet","loc":{"line":1,"column":7},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\SingleIOProcessor.worklet.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\ToneAudioWorkletProcessor.worklet.js"},{"name":"./WorkletGlobalScope","loc":{"line":2,"column":29},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\SingleIOProcessor.worklet.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\WorkletGlobalScope.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.singleIOProcess = void 0;\n\nrequire(\"./ToneAudioWorkletProcessor.worklet\");\n\nvar _WorkletGlobalScope = require(\"./WorkletGlobalScope\");\n\nconst singleIOProcess =\n/* javascript */\n`\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\nexports.singleIOProcess = singleIOProcess;\n(0, _WorkletGlobalScope.addToWorklet)(singleIOProcess);"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":8,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":10,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":7},"generated":{"line":12,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":13},"generated":{"line":12,"column":6}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":28},"generated":{"line":12,"column":21}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":31},"generated":{"line":13,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":48},"generated":{"line":14,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":7},"generated":{"line":81,"column":1}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":83,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":13},"generated":{"line":83,"column":38}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":83,"column":53}}],"sources":{"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts":"import \"./ToneAudioWorkletProcessor.worklet\";\nimport { addToWorklet } from \"./WorkletGlobalScope\";\n\nexport const singleIOProcess = /* javascript */ `\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\n\naddToWorklet(singleIOProcess);\n"},"lineCount":null}},"error":null,"hash":"1560e317fcc3a97fc07b5dcc4a598180","cacheData":{"env":{}}}