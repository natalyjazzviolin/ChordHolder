{"id":"yDU0","dependencies":[{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\SingleIOProcessor.worklet.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\Tone\\core\\worklet\\SingleIOProcessor.worklet.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\package.json","includedInParent":true,"mtime":1596313565786},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\package.json","includedInParent":true,"mtime":1596312949653},{"name":"./ToneAudioWorkletProcessor.worklet","loc":{"line":1,"column":7},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\SingleIOProcessor.worklet.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\ToneAudioWorkletProcessor.worklet.js"},{"name":"./WorkletGlobalScope","loc":{"line":2,"column":29},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\SingleIOProcessor.worklet.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\WorkletGlobalScope.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.singleIOProcess=void 0,require(\"./ToneAudioWorkletProcessor.worklet\");var t=require(\"./WorkletGlobalScope\");const e=\"\\n\\t/**\\n\\t * Abstract class for a single input/output processor. \\n\\t * has a 'generate' function which processes one sample at a time\\n\\t */\\n\\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\\n\\n\\t\\tconstructor(options) {\\n\\t\\t\\tsuper(Object.assign(options, {\\n\\t\\t\\t\\tnumberOfInputs: 1,\\n\\t\\t\\t\\tnumberOfOutputs: 1\\n\\t\\t\\t}));\\n\\t\\t\\t/**\\n\\t\\t\\t * Holds the name of the parameter and a single value of that\\n\\t\\t\\t * parameter at the current sample\\n\\t\\t\\t * @type { [name: string]: number }\\n\\t\\t\\t */\\n\\t\\t\\tthis.params = {}\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Generate an output sample from the input sample and parameters\\n\\t\\t * @abstract\\n\\t\\t * @param input number\\n\\t\\t * @param channel number\\n\\t\\t * @param parameters { [name: string]: number }\\n\\t\\t * @returns number\\n\\t\\t */\\n\\t\\tgenerate(){}\\n\\n\\t\\t/**\\n\\t\\t * Update the private params object with the \\n\\t\\t * values of the parameters at the given index\\n\\t\\t * @param parameters { [name: string]: Float32Array },\\n\\t\\t * @param index number\\n\\t\\t */\\n\\t\\tupdateParams(parameters, index) {\\n\\t\\t\\tfor (const paramName in parameters) {\\n\\t\\t\\t\\tconst param = parameters[paramName];\\n\\t\\t\\t\\tif (param.length > 1) {\\n\\t\\t\\t\\t\\tthis.params[paramName] = parameters[paramName][index];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthis.params[paramName] = parameters[paramName][0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Process a single frame of the audio\\n\\t\\t * @param inputs Float32Array[][]\\n\\t\\t * @param outputs Float32Array[][]\\n\\t\\t */\\n\\t\\tprocess(inputs, outputs, parameters) {\\n\\t\\t\\tconst input = inputs[0];\\n\\t\\t\\tconst output = outputs[0];\\n\\t\\t\\t// get the parameter values\\n\\t\\t\\tconst channelCount = Math.max(input && input.length || 0, output.length);\\n\\t\\t\\tfor (let sample = 0; sample < this.blockSize; sample++) {\\n\\t\\t\\t\\tthis.updateParams(parameters, sample);\\n\\t\\t\\t\\tfor (let channel = 0; channel < channelCount; channel++) {\\n\\t\\t\\t\\t\\tconst inputSample = input && input.length ? input[channel][sample] : 0;\\n\\t\\t\\t\\t\\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn !this.disposed;\\n\\t\\t}\\n\\t};\\n\";exports.singleIOProcess=e,(0,t.addToWorklet)(e);"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":13}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":20}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":35}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":43}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":56}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":57}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":64}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":68}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":76}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":97}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":1,"column":99}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":1,"column":107}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":1,"column":146}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":1,"column":150}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":1,"column":152}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":1,"column":160}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":7},"generated":{"line":1,"column":184}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":13},"generated":{"line":1,"column":190}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":48},"generated":{"line":1,"column":192}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":2337}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":2345}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":2361}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":1,"column":2364}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":13},"generated":{"line":1,"column":2366}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":13},"generated":{"line":1,"column":2368}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":13},"generated":{"line":1,"column":2382}}],"sources":{"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts":"import \"./ToneAudioWorkletProcessor.worklet\";\nimport { addToWorklet } from \"./WorkletGlobalScope\";\n\nexport const singleIOProcess = /* javascript */ `\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\n\naddToWorklet(singleIOProcess);\n"},"lineCount":null}},"error":null,"hash":"b27d5544b4466abc10955d03f105b9b8","cacheData":{"env":{}}}