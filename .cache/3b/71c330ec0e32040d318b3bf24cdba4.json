{"id":"KlZo","dependencies":[{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\DelayLine.worklet.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\Tone\\core\\worklet\\DelayLine.worklet.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\package.json","includedInParent":true,"mtime":1596313565786},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\package.json","includedInParent":true,"mtime":1596312949653},{"name":"./WorkletGlobalScope","loc":{"line":1,"column":29},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\DelayLine.worklet.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\WorkletGlobalScope.js"}],"generated":{"js":"\"use strict\";var t=require(\"./WorkletGlobalScope\");const e=\"\\n\\t/**\\n\\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\\n\\t */\\n\\tclass DelayLine {\\n\\t\\t\\n\\t\\tconstructor(size, channels) {\\n\\t\\t\\tthis.buffer = [];\\n\\t\\t\\tthis.writeHead = []\\n\\t\\t\\tthis.size = size;\\n\\n\\t\\t\\t// create the empty channels\\n\\t\\t\\tfor (let i = 0; i < channels; i++) {\\n\\t\\t\\t\\tthis.buffer[i] = new Float32Array(this.size);\\n\\t\\t\\t\\tthis.writeHead[i] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Push a value onto the end\\n\\t\\t * @param channel number\\n\\t\\t * @param value number\\n\\t\\t */\\n\\t\\tpush(channel, value) {\\n\\t\\t\\tthis.writeHead[channel] += 1;\\n\\t\\t\\tif (this.writeHead[channel] > this.size) {\\n\\t\\t\\t\\tthis.writeHead[channel] = 0;\\n\\t\\t\\t}\\n\\t\\t\\tthis.buffer[channel][this.writeHead[channel]] = value;\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Get the recorded value of the channel given the delay\\n\\t\\t * @param channel number\\n\\t\\t * @param delay number delay samples\\n\\t\\t */\\n\\t\\tget(channel, delay) {\\n\\t\\t\\tlet readHead = this.writeHead[channel] - Math.floor(delay);\\n\\t\\t\\tif (readHead < 0) {\\n\\t\\t\\t\\treadHead += this.size;\\n\\t\\t\\t}\\n\\t\\t\\treturn this.buffer[channel][readHead];\\n\\t\\t}\\n\\t}\\n\";(0,t.addToWorklet)(e);"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":0},"generated":{"line":1,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":1,"column":13}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":1,"column":17}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":1,"column":19}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":1,"column":27}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":1,"column":51}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":6},"generated":{"line":1,"column":57}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":35},"generated":{"line":1,"column":59}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":0},"generated":{"line":1,"column":1204}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":13},"generated":{"line":1,"column":1206}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":13},"generated":{"line":1,"column":1208}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":13},"generated":{"line":1,"column":1222}}],"sources":{"../../../../Tone/core/worklet/DelayLine.worklet.ts":"import { addToWorklet } from \"./WorkletGlobalScope\";\n\nconst delayLine = /* javascript */ `\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n`;\n\naddToWorklet(delayLine);\n"},"lineCount":null}},"error":null,"hash":"fce08b25cf1eb263ee62baab955cab3a","cacheData":{"env":{}}}