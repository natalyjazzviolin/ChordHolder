{"id":"../node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js","dependencies":[{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\DelayLine.worklet.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\Tone\\core\\worklet\\DelayLine.worklet.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\package.json","includedInParent":true,"mtime":1596313565786},{"name":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\package.json","includedInParent":true,"mtime":1596312949653},{"name":"./WorkletGlobalScope","loc":{"line":1,"column":29},"parent":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\DelayLine.worklet.js","resolved":"C:\\Users\\natal\\Documents\\chord-holder-v1\\node_modules\\tone\\build\\esm\\core\\worklet\\WorkletGlobalScope.js"}],"generated":{"js":"\"use strict\";\n\nvar _WorkletGlobalScope = require(\"./WorkletGlobalScope\");\n\nconst delayLine =\n/* javascript */\n`\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n`;\n(0, _WorkletGlobalScope.addToWorklet)(delayLine);"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":3,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":5,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":6},"generated":{"line":5,"column":6}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":15},"generated":{"line":5,"column":15}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":18},"generated":{"line":6,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":35},"generated":{"line":7,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":51,"column":1}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":0},"generated":{"line":52,"column":0}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":13},"generated":{"line":52,"column":38}},{"source":"../../../../Tone/core/worklet/DelayLine.worklet.ts","name":null,"original":{"line":49,"column":0},"generated":{"line":52,"column":47}}],"sources":{"../../../../Tone/core/worklet/DelayLine.worklet.ts":"import { addToWorklet } from \"./WorkletGlobalScope\";\n\nconst delayLine = /* javascript */ `\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n`;\n\naddToWorklet(delayLine);\n"},"lineCount":null}},"error":null,"hash":"9bfe7be1176463bdd83e137f20907ca1","cacheData":{"env":{}}}